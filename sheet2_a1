import numpy as np
import timeit
from matplotlib import pyplot as plt
import cv2
from vstru2mw import vstru2mw

from skimage.util import img_as_ubyte
from skimage.filters.rank import entropy
from skimage.morphology import disk, square
from skimage.color import rgb2hsv, rgb2gray, rgb2yuv
from balg_utils import race_functions, difference_image, read_image



#class for circular mask
class CircularMask:
    def __init__(self, radius):
        self.radius = radius
        self.mask = self.create_mask()
        self.mask_size = self.mask.shape[0]
        self.mask_center = self.mask_size // 2
        self.mask_sum = np.sum(self.mask)
        self.mask_sum_half = self.mask_sum // 2

    def create_mask(self):
        mask = np.zeros((self.radius * 2 + 1, self.radius * 2 + 1))
        for i in range(mask.shape[0]):
            for j in range(mask.shape[1]):
                if (i - self.radius) ** 2 + (j - self.radius) ** 2 < self.radius ** 2:
                    mask[i, j] = 1
        return mask

    def apply_mask(self, img, x, y):
        mask_img = np.zeros((self.mask_size, self.mask_size))
        for i in range(self.mask_size):
            for j in range(self.mask_size):
                mask_img[i, j] = img[y + i - self.mask_center, x + j - self.mask_center] * self.mask[i, j]
        return mask_img



def median_huang(img, s):
    # check if the mask size is odd
    if s % 2 == 0:
        raise ValueError('Mask size must be odd')
    # create a new image with the same size as the input image
    median_img = np.zeros(img.shape)
    #create empty histogram with 256 bins
    hist = np.zeros(256)
    #iterate over the image lines and ignore the border pixels
    for j in range(s // 2, img.shape[0] - (s // 2)):
        #initialize the histogram for the line
        init_histogram(img, hist, s//2, j, s)
        #iterate over the line and ignore the border pixels
        for i in range(s // 2, img.shape[1] - (s // 2)):
            #calculate the median of the histogram
            #todo median mit medianpointer berechnen
            median_img[j, i] = np.argmax(np.cumsum(hist) >= (s * s) / 2)
            #update the histogram for the next iteration
            update_histogram(img, hist, i, j, s)
    return median_img.astype(np.uint8)



def entropy_ala_huang_LUT(img, s):
    # check if the mask size is odd
    if s % 2 == 0:
        raise ValueError('Mask size must be odd')
    #calculate the LUT
    LUT = gen_LUT_plog2p(square(s))
    # create a new image with the same size as the input image
    entropy_img = np.zeros(img.shape)
    #create empty histogram with 256 bins
    hist = np.zeros(256)
    #iterate over the image lines and ignore the border pixels
    for j in range(s // 2, img.shape[0] - (s // 2)):
        #initialize the histogram for the line
        init_histogram(img, hist, s//2, j, s)
        #iterate over the line and ignore the border pixels
        for i in range(s // 2, img.shape[1] - (s // 2)):
            #calculate the entropy of the histogram
            entropy_img[j, i] = calc_entropy_wLUT(hist, LUT)
            #update the histogram for the next iteration
            update_histogram(img, hist, i, j, s)
    return entropy_img



def entropy_ala_huang(img, s):
    # check if the mask size is odd
    if s % 2 == 0:
        raise ValueError('Mask size must be odd')
    # create a new image with the same size as the input image
    entropy_img = np.zeros(img.shape)
    #create empty histogram with 256 bins
    hist = np.zeros(256)
    #iterate over the image lines and ignore the border pixels
    for j in range(s // 2, img.shape[0] - (s // 2)):
        #initialize the histogram for the line
        init_histogram(img, hist, s//2, j, s)
        #iterate over the line and ignore the border pixels
        for i in range(s // 2, img.shape[1] - (s // 2)):
            #calculate the entropy of the histogram
            entropy_img[j, i] = calc_entropy_woLUT(hist)
            #update the histogram for the next iteration
            update_histogram(img, hist, i, j, s)
    return entropy_img


def entropy_ala_huang_vnormal(img, mask_in):
    # check if the mask size is odd
    if mask_in.shape[0] % 2 == 0:
        raise ValueError('Mask size must be odd')
    LUT = gen_LUT_plog2p(mask_in)
    mask = vstru2mw(mask_in)
    # create a new image with the same size as the input image
    entropy_img = np.zeros(img.shape)
    # filter_height = mask.shape[0]
    # filter_width = mask[]]

    #create empty histogram with 256 bins
    hist = np.zeros(256)
    #iterate over the image lines and ignore the border pixels
    for j in range(int(mask[0][0]), img.shape[0] - int(mask[0][0])):
        #initialize the histogram for the line
        init_histogram2(img, hist, int(mask[0][0]), j, mask)
        #iterate over the line and ignore the border pixels
        for i in range(mask.shape[0]//2, img.shape[1] - mask.shape[0]//2):
            #calculate the entropy of the histogram
            entropy_img[j, i] = calc_entropy_wLUT(hist, LUT)
            #update the histogram for the next iteration
            update_histogram2(img, hist, i, j, mask)
    return entropy_img



def calc_entropy_wLUT(hist, LUT):
    #calculate the entropy of the histogram 
    hist = hist[hist > 0].astype(np.int64)
    #calc entropy with LUT
    entr = - np.sum(LUT[hist-1])
    return entr


def calc_entropy_woLUT(hist):
    # calculate the entropy of the histogram 
    # hist = hist / np.sum(hist)
    hist = hist[hist > 0].astype(np.int64)
    #calc entropy without LUT
    entr = -np.sum(hist * np.log2(hist))
    return entr



def init_histogram(img, hist, x, y, s):
    #fill histogramm with 0
    hist.fill(0)
    #iterate over the mask and fill histogram
    for j in range(-(s // 2), s // 2 + 1):
        for i in range(-(s // 2), s // 2 + 1):
            hist[img[y+j, x+i]] += 1
    return


def update_histogram(img, hist, x, y, s):
    #remove values from the histogram that are not in the mask anymore
    for j in range(-(s // 2), s // 2 + 1):
        hist[img[ y + j, x - s // 2]] -= 1
        if(x + s // 2 + 1 < img.shape[0]):
            hist[img[y + j, x + s // 2 + 1]] += 1
    return


def init_histogram2(img, hist, x, y, filter):
    #fill histogramm with 0
    hist.fill(0)
    #iterate over the mask and fill histogram
    k=0
    for j in range(int(-filter[k][2]), int(filter[k][2]) + 1):
        for i in range(-int(filter[k][0]-filter[k][2]), int(filter[k][0]-filter[k][2])+1):
            hist[img[y+j, x+i]] += 1
        k+=1
    return


def update_histogram2(img, hist, x, y, filter):
    #update histogram
    k=0
    for j in range(int(-filter[k][2]), int(filter[k][2]) + 1):
        hist[img[ y + j, x - (int(filter[k][1]//2))]] -= 1
        if(x + (int(filter[k][1]//2))+1 < img.shape[0]):
            hist[img[y + j, x + (int(filter[k][1]//2))+1]] += 1
        k+=1
    return





def gen_LUT_plog2p(mask):
    #count non zero elements in mask
    num_entries = np.sum(mask)
    #create LUT
    i = np.arange(1,num_entries+1,1)        
    pi = i/num_entries
    LUT = pi*np.log2(1/pi)
    return LUT


# create median image with cv2.medianBlur
def median_cv2(img, s):
    median_img = cv2.medianBlur(img, s)
    return median_img


testarray = [[10,5,6,20,4,10,8],
            [15,1,7,2,9,11,7],
            [18,4,3,6,8,10,12],
            [1,6,7,8,9,20,21],
            [10,15,18,2,1,3,4],
            [20,14,15,9,2,1,10],
            [18,4,3,6,8,10,12]]

testarray = np.array(testarray).astype(np.uint8)
# #testarray = read_image(0)
# median_huang_img = median_huang(testarray, 3)
# median_cv2_img = median_cv2(testarray, 3)





mask = disk(2)

img = read_image(2)
img_entropy_scipy = entropy(img, mask)
img_entropy_vnormal = entropy_ala_huang_vnormal(img, mask)
difference_image(img_entropy_scipy, img_entropy_vnormal, 'scipy', 'vnormal')


img_entropy_scipy = entropy(img, square(3))
img_entropy_lut = entropy_ala_huang_LUT(img, 3)
difference_image(img_entropy_scipy, img_entropy_lut, 'scipy', 'entropy ala huang')



# #calculate the difference between the both results
# diff = median_huang_img - median_cv2_img
# #show the both median images and the difference
# plt.figure(figsize=(15, 15))
# plt.subplot(1, 3, 1)
# plt.imshow(median_huang_img, cmap='gray')
# plt.title('Median with Huan\'s Algorithm')
# plt.subplot(1, 3, 2)
# plt.imshow(median_cv2_img, cmap='gray')
# plt.title('Median with cv2.medianBlur')
# plt.subplot(1, 3, 3)
# plt.imshow(diff, cmap='gray')
# plt.title('Difference')
# plt.show()

# entropy_with_LUT = entropy_ala_huang_LUT(testarray, 3)
# entropy_wo_LUT = entropy_ala_huang(testarray, 3)
# difference_image(entropy_with_LUT, entropy_wo_LUT, 'Entropy with LUT', 'Entropy without LUT')



# entropy_huang_img = median_entropy_ala_huang_LUT(testarray, 3)
# entropy_huang_img_woLUT = median_entropy_ala_huang(testarray, 3)
# entropy_cv2_img = entropy(testarray, square(3))

# diff_w_wo_LUT = np.abs(entropy_huang_img_woLUT- entropy_huang_img).astype(np.uint8)
# #print maximum difference
# print('Maximum gray value difference in Entropy Calculation with and without LUT: ', np.max(diff_w_wo_LUT))

# #calculate the difference between the both results
# diff = (entropy_huang_img - entropy_cv2_img).astype(np.uint8)
# #show the both median images and the difference
# plt.figure(figsize=(15, 10))
# plt.subplot(1, 5, 1)
# plt.imshow(entropy_huang_img, cmap='gray')
# plt.title('Entropy with Huan\'s Algorithm and LUT')
# plt.subplot(1, 5, 3)
# plt.imshow(entropy_cv2_img, cmap='gray')
# plt.title('Entropy with skimage.filters.rank.entropy')
# plt.subplot(1, 5, 4)
# plt.imshow(diff, cmap='gray')
# plt.title('Difference')
# plt.show()






